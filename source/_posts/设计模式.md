---
title: 设计模式基础
date: 2017-02-28 17:05:46
tags:
  - 设计模式
---
# 基本设计模式
## 基本的00基础
抽象，封装，多态，继承
## 策略模式
定义了算法簇，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
    例子：
##  观察者模式
定义了对象之间的一对多以来，这样以来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
观察者模式让主题和观察者之间送耦合
    
例子：
    
##  装饰者模式
动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
用一系列的装饰方法（类）去装饰对象，使对象呈现最终需要的结果
    
在JAVA中 java I/O就使用了标准的装饰者模式
例子：
    
## 工厂模式
封装创建对象的代码
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
    
    
## 抽象工厂模式
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
    
例子：

## 单例模式
独一无二的对象，用来创建独一无二的，只能有一个实例对象
将构造器私有化
确保一个类只有一个实例，并提供一个全局访问点
    
```java
    public class Singleton{
        private volatile static Singleton uniqueInstance;
        private Singleton(){}
        public static Singleton getInstance(){
            if(uniqueInstance == null){
                synchronized(Singleton.class){
                    if(uniqueInstance == null){
                        uniqueInstance = new Singleton();
                    }
                }
            }
            return uniqueInstance;
        }
    }
```
## 命令模式
把方法调用（method invocation）封装起来
将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持撤销的操作
### 命令模式的更多用途
1. 队列请求
2. 日志请求

## 适配器模式
将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。    
本身包含类
类适配器和对象适配器两种
其中类适配器需要多重继承，java不支持
## 外观模式
提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
## 模板方法模式
封装算法
定义了一个算法的步骤，允许子类为一个或多个步骤提供实现
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
    
可以设置一个钩子方法，允许子类重定义钩子方法确定算法的执行逻辑
## 迭代器模式
提供一种方法顺序访问一个聚会对象中的各个元素，而又不是暴露其内部的表示
        
## 组合模式
允许你将对象组合成树形结构来表现"整体/部分"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合
    
## 状态模式
允许对象在内部状态改变是改变它的行为，对象看起来好像修改了它的类
        
## MVC模式
+ 视图（view）：用来呈现模型。视图通常直接从模型中取得它需要显示的状态与数据
+ 控制器（conctrol）：取得用户的输入并解读其对模型的意思
+ 模型（model）：模型持有所有的数据、状态和程序逻辑。模型没有注意到视图和控制器，虽然它提供了操作和检索状态的接口，并发送状态改变通知给观察者。
